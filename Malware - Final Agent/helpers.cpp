#include "PEstructs.h"
#include "helpers.h"
#include <stdio.h>
#include <string>

unsigned char syscallSignature[] = { 0x4c, 0x8b, 0xd1, 0xb8 }; // First bytes of every syscall

LPCWSTR toLPCWSTR(std::string input)
{
	// Calculate the length of the wide string
	int wideStrLen = MultiByteToWideChar(CP_UTF8, 0, input.c_str(), -1, nullptr, 0);
	if (wideStrLen <= 0) return NULL;

	// Allocate memory for the wide string
	wchar_t* wideStr = new wchar_t[wideStrLen];
	MultiByteToWideChar(CP_UTF8, 0, input.c_str(), -1, wideStr, wideStrLen);

	return wideStr;
}

char* UnicodeStringToChar(UNICODE_STRING unicodeString) {
	int bufferSize = WideCharToMultiByte(CP_UTF8, 0, unicodeString.Buffer, unicodeString.Length / sizeof(wchar_t), nullptr, 0, nullptr, nullptr);

	char* buffer = new char[bufferSize + 1];  // +1 for null terminator
	WideCharToMultiByte(CP_UTF8, 0, unicodeString.Buffer, unicodeString.Length / sizeof(wchar_t), buffer, bufferSize, nullptr, nullptr);

	// Null-terminate the string
	buffer[bufferSize] = '\0';

	for (int i = 0; buffer[i]; ++i) {
		buffer[i] = std::tolower(static_cast<unsigned char>(buffer[i]));
	}

	return buffer;
}

HMODULE WINAPI hlpGetModuleHandle(std::string sModuleName) {

	// get the offset of Process Environment Block
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	LPCWSTR sModuleName_w = toLPCWSTR(sModuleName.c_str());

	// return base address of a calling module
	if (sModuleName_w == NULL)
		return (HMODULE)(ProcEnvBlk->ImageBaseAddress);

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	for (LIST_ENTRY* pListEntry = pStartListEntry;  		// start from beginning of InMemoryOrderModuleList
		pListEntry != ModuleList;	    	// walk all list entries
		pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and return its base address
		if (lstrcmpiW(pEntry->BaseDllName.Buffer, sModuleName_w) == 0)
			return (HMODULE)pEntry->DllBase;
	}

	// otherwise:
	return NULL;

}

HMODULE WINAPI hashGetModuleHandle(DWORD sModuleName_hash) {

	// get the offset of Process Environment Block
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	// return base address of a calling module
	if (sModuleName_hash == 0x0)
		return (HMODULE)(ProcEnvBlk->ImageBaseAddress);

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	for (LIST_ENTRY* pListEntry = pStartListEntry;  		// start from beginning of InMemoryOrderModuleList
		pListEntry != ModuleList;	    	// walk all list entries
		pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		char* current_dllname = UnicodeStringToChar(pEntry->BaseDllName);

		// check if module is found and return its base address
		if (W1n4P1H4sh(current_dllname) == sModuleName_hash)
			return (HMODULE)pEntry->DllBase;
	}

	// otherwise:
	return NULL;

}

FARPROC WINAPI hlpGetProcAddress(HMODULE hMod, std::string sProcName) {

	char* pBaseAddr = (char*)hMod;

	// get pointers to main headers/structures
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress);

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	// function address we're looking for
	void* pProcAddr = NULL;

	// parse through table of function names
	for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
		char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];

		if (strcmp(sProcName.c_str(), sTmpFuncName) == 0) {
			// found, get the function virtual address = RVA + BaseAddr
			pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]]);
			break;
		}
	}

	return (FARPROC)pProcAddr;
}

FARPROC WINAPI hashGetProcAddress(HMODULE hMod, DWORD sProcName_hash) {

	char* pBaseAddr = (char*)hMod;

	// get pointers to main headers/structures
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress);

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	// function address we're looking for
	void* pProcAddr = NULL;

	// parse through table of function names
	for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
		char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];


		if (W1n4P1H4sh(sTmpFuncName) == sProcName_hash) {
			// found, get the function virtual address = RVA + BaseAddr
			pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]]);
			break;
		}
	}

	return (FARPROC)pProcAddr;
}

bool isHooked(PVOID pProc)
{
	for (int i = 0; i < sizeof(syscallSignature); i++)
	{
		if (((unsigned char*)pProc)[i] != syscallSignature[i]) return true;
	}

	return false;
}

bool hashFindSSN(DWORD sModule, DWORD sProc, UINT32* p_ssn, UINT64* p_retAddress)
{
	HMODULE hNtdll = hashGetModuleHandle(sModule);
	PVOID orig_pProc = hashGetProcAddress(hNtdll, sProc);
	PVOID pProc = orig_pProc;

	for (int i = 0; i < 20; i++)
	{
		pProc = (PVOID)((ULONGLONG)pProc - 0x20 * i); // syscalls are usually 0x20 bytes apart

		if (!isHooked(pProc))
		{
			*p_ssn = *((int*)((ULONGLONG)pProc + 4)) + i; // SSN are incremental
			*p_retAddress = (ULONGLONG)orig_pProc + 0x12; // Address to jmp in order to hide call stack
			return true;
		}
	}

	return false;
}

// Hash function
DWORD W1n4P1H4sh(const char* input) {
	size_t stringLength = strlen(input);
	DWORD hashValue = 0x35;

	for (size_t i = 0; i < stringLength; ++i) {
		hashValue = (hashValue + (hashValue << 4) + static_cast<unsigned char>(input[i])) & 0xFFFFFF;
	}

	return hashValue;
}

void fX0R(char* data, size_t data_len, char* key, size_t key_len) {
	int j;

	j = 0;
	for (int i = 0; i < data_len; i++) {
		data[i] = data[i] ^ key[j % key_len];
		j++;
	}
}