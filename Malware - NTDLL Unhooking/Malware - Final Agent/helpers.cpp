#include "PEstructs.h"
#include "helpers.h"
#include <stdio.h>
#include <string>

unsigned char syscallSignature[] = { 0x4c, 0x8b, 0xd1, 0xb8 }; // First bytes of every syscall

LPCWSTR toLPCWSTR(std::string input)
{
	// Calculate the length of the wide string
	int wideStrLen = MultiByteToWideChar(CP_UTF8, 0, input.c_str(), -1, nullptr, 0);
	if (wideStrLen <= 0) return NULL;

	// Allocate memory for the wide string
	wchar_t* wideStr = new wchar_t[wideStrLen];
	MultiByteToWideChar(CP_UTF8, 0, input.c_str(), -1, wideStr, wideStrLen);

	return wideStr;
}

HMODULE WINAPI hlpGetModuleHandle(std::string sModuleName) {

	// get the offset of Process Environment Block
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	LPCWSTR sModuleName_w = toLPCWSTR(sModuleName.c_str());

	// return base address of a calling module
	if (sModuleName_w == NULL)
		return (HMODULE)(ProcEnvBlk->ImageBaseAddress);

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	for (LIST_ENTRY* pListEntry = pStartListEntry;  		// start from beginning of InMemoryOrderModuleList
		pListEntry != ModuleList;	    	// walk all list entries
		pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and return its base address
		if (lstrcmpiW(pEntry->BaseDllName.Buffer, sModuleName_w) == 0)
			return (HMODULE)pEntry->DllBase;
	}

	// otherwise:
	return NULL;

}

FARPROC WINAPI hlpGetProcAddress(HMODULE hMod, std::string sProcName) {

	char* pBaseAddr = (char*)hMod;

	// get pointers to main headers/structures
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress);

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	// function address we're looking for
	void* pProcAddr = NULL;

	// parse through table of function names
	for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
		char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];

		if (strcmp(sProcName.c_str(), sTmpFuncName) == 0) {
			// found, get the function virtual address = RVA + BaseAddr
			pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]]);
			break;
		}
	}

	return (FARPROC)pProcAddr;
}

bool isHooked(PVOID pProc)
{
	for (int i = 0; i < sizeof(syscallSignature); i++)
	{
		if (((unsigned char*)pProc)[i] != syscallSignature[i]) return true;
	}

	return false;
}

bool findSSN(std::string procName, UINT32* p_ssn, UINT64* p_retAddress)
{
	HMODULE hNtdll = hlpGetModuleHandle("ntdll.dll");
	PVOID orig_pProc = hlpGetProcAddress(hNtdll, procName);
	PVOID pProc = orig_pProc;

	for (int i = 0; i < 20; i++)
	{
		pProc = (PVOID)((ULONGLONG)pProc - 0x20 * i); // syscalls are usually 0x20 bytes apart

		if (!isHooked(pProc))
		{
			*p_ssn = *((int*)((ULONGLONG)pProc + 4)) + i; // SSN are incremental
			*p_retAddress = (ULONGLONG)orig_pProc + 0x12; // Address to jmp in order to hide call stack
			return true;
		}
	}

	return false;
}